# 一篇就够了：`HTTP`基础知识一网打尽

![一篇就够了：HTTP 基础知识一网打尽](/network.jpg)

## `HTTP`协议

`HTTP` 协议是一种无状态的、处于应用层的、以请求/应答方式运行的协议，使用可扩展的语义和自描述的信息格式，与基于网络的超文本信息系统灵活的相互作用。

### 与`HTTP`相关的协议

#### `OSI`模型

`OSI`（Open System Interconnection Reference Model），开放式系统互联通信参考模型，也就是我们常说的 7 层模型。从它的名称就可以看出来，`OSI` 只是一个供参考的概念模型，它从未被真正的实现。`OSI` 的 7 层，从上至下分别是：

![OSI模型](/osi.jpg)

| `OSI`分层 | 作用 |
| :-----| :---- |
| L7 应用层 | 解决业务问题，面向具体的应用传输数据 |
| L6 表示层 | 将消息转换为应用层可以读取的消息 |
| L5 会话层 | 建立会话、握手、维持网络的连接状态 |
| L4 传输层 | 包括我们熟悉的 `TCP` 与 `UDP` 等，解决进程与进程之间的通讯 |
| L3 网络层 | 主要包括 `IP` 协议，负责将报文从因特网上的一个主机发送到另一个主机上 |
| L2 数据链路层 | 工作在局域网中，使用 `MAC` 地址标记网络上的设备，如路由器，然后将报文转到主机上 |
| L1 物理层 | 电缆、光纤等 |

#### `TCP/IP`模型

`OSI` 只是一个概念模型，而平常工作我们最常用的还是 `TCP/IP` 模型。`TCP/IP` 模型其实就是 `OSI` 模型的简化版本，也就是我们平时所说的 4 层模型。`TCP/IP` 的 4 层，由上至下分别是：

![TCP/IP模型](/tcpip.jpg)

通过上图我们可以看出，其实 `TCP/IP` 模型与 `OSI` 模型十分相似，主要是省略了表示层、会话层与物理层的实现。这里每一层的功能实际上与对应的 `OSI` 模型十分类似，所以就不再罗列了。下面是一张 `OSI` 模型与 `TCP/IP` 模型的层级对照图，大家可以通过对照图来总结 `TCP/IP` 模型中各层的职责。

![OSI-TCP/IP模型](/osi-tcpip.jpg)

网络分层的好处是，每一次层都只负责自己的任务，其他层的事情完全不需要考虑，层次之间交互的时候，只需要调用接口就可以了。当某一层需要修改的时候，也完全不影响其他的功能。当然，有优势就一定有劣势，每一次进行网络通信的时候，都需要由上至下，一层一层的传递信息，反过来，又要一层一层的向上传递，对于性能的影响是比较大的。

#### `TCP`三次握手、四次挥手

#### `URL`的组成

#### `DNS`工作原理

### `HTTP`的特点

`HTTP`是一个属于应用层的面向对象的协议，`HTTP`协议一共有五大特点：

* **支持客户/服务器模式**
* **简单快速**：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有`GET`、`HEAD`、`POST`。每种方法规定了客户与服务器联系的类型不同。由于`HTTP`协议简单，使得`HTTP`服务器的程序规模小，因而通信速度很快。
* **灵活**：`HTTP`允许传输任意类型的数据对象。正在传输的类型由`Content-Type`（`Content-Type`是`HTTP`包中用来表示内容类型的标识）加以标记。
* **无连接**：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
* **无状态**：`HTTP`协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

### `HTTP`的缺点

* **无状态**：无状态在部分场景下是缺点，比如：购物系统，无法保留顾客信息。
* **明文传输**：协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。这让`HTTP`的报文信息暴露给了外界，给攻击者带来了便利。
* **队头阻塞**：当同时发起多个`HTTP`请求时，共用一个`TCP`连接，当某个请求时间过长时，其他的请求只能处于阻塞状态，这就是队头阻塞问题。

## `HTTP` 版本

### `HTTP 0.9`

* 1991年,原型版本，功能简陋，只有一个命令`GET`，只支持纯文本内容，该版本已过时。

### `HTTP 1.0`

* 任何格式的内容都可以发送，这使得互联网不仅可以传输文字，还能传输图像、视频、二进制等文件。
* 除了`GET`命令，还引入了`POST`命令和`HEAD`命令。
* `http`请求和回应的格式改变，除了数据部分，每次通信都必须包括头信息（`HTTP header`），用来描述一些元数据。
* 只使用 `header` 中的 `If-Modified-Since` 和 `Expires` 作为缓存失效的标准。
* 不支持断点续传，也就是说，每次都会传送全部的页面和数据。
* 通常每台计算机只能绑定一个 `IP`，所以请求消息中的 `URL` 并没有传递主机名（`hostname`）

### `HTTP 1.1`

`http1.1`是目前最为主流的`http`协议版本，从1999年发布至今，仍是主流的`http`协议版本。

* **持久连接**：即`TCP`连接默认不关闭，可以被多个请求复用，不用声明`Connection: keep-alive`。长连接的连接时长可以通过请求头中的 `keep-alive` 来设置。
* **管道机制**：即在同一个`TCP`连接里，客户端可以同时发送多个请求，进一步改进了HTTP协议的效率。
* `HTTP 1.1` 中新增加了 `E-tag`，`If-Unmodified-Since`, `If-Match`, `If-None-Match` 等缓存控制标头来控制缓存失效。
* **断点续传**：通过使用请求头中的 `Range` 来实现。
* **虚拟网络**：在一台物理服务器上可以存在多个虚拟主机（`Multi-homed Web Servers`），并且它们共享一个`IP`地址。
* 新增方法：`PUT`、 `PATCH`、 `OPTIONS`、 `DELETE`。

### `HTTP 2.0`

* **二进制分帧**：这是一次彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"：头信息帧和数据帧。
* **头部压缩**：`HTTP 1.1`版本会出现 `User-Agent`、`Cookie`、`Accept`、`Server`、`Range` 等字段可能会占用几百甚至几千字节，而 `Body` 却经常只有几十字节，所以导致头部偏重。`HTTP 2.0` 使用 `HPACK` 算法进行压缩。
* **多路复用**：复用`TCP`连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了队头阻塞的问题。
* **服务器推送**：允许服务器未经请求，主动向客户端发送资源，即服务器推送。
* **请求优先级**：可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。

## 请求方法

`HTTP1.0`定义了三种请求方法： `GET`、 `POST` 和 `HEAD`方法。

`HTTP1.1`新增了五种请求方法：`OPTIONS`、`PUT`、 `DELETE`、 `TRACE` 和 `CONNECT`。

| 方法 | 含义 |
| :-----| :---- |
| `GET` | 通常用于请求服务器发送某些资源 |
| `HEAD` | 请求资源的头部信息, 并且这些头部与 `HTTP` `GET` 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源 |
| `OPTIONS` | 用于获取目的资源所支持的通信选项 |
| `POST` | 发送数据给服务器 |
| `PUT` | 用于新增资源或者使用请求中的有效负载替换目标资源的表现形式 |
| `DELETE` | 用于删除指定的资源 |
| `PATCH` | 用于对资源进行部分修改 |
| `CONNECT` | `HTTP/1.1`协议中预留给能够将连接改为管道方式的代理服务器 |
| `TRACE` | 回显服务器收到的请求，主要用于测试或诊断 |

## 常见错误码

### 1xx 信息类

### 2xx 成功

### 3xx 重定向

### 4xx 客户端错误

### 5xx 服务器错误

## 缓存策略

## HTTPS
